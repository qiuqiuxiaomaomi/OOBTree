# OOBTree
面向对象杂谈


![](https://i.imgur.com/SRppvZ1.png)

<pre>
面向对象:
      1)面向对象是一种常见的思想，比较符合人们的思考习惯。
      2）面向对象可以将复杂的业务逻辑简单化，增强代码复用性。
      3）面向对象具有抽象，继承，多态等特性。

      类：
        对某类事务的普遍一致性特征，功能的抽象，描述和封装，是构造对象的模板或蓝图，用Java
      编写的代码都会在某些类的内部。类之间主要有：
                                           1）依赖
                                           2）继承
                                           3）聚合
                                           等关系。
      
      对象：
          使用new关键字或反射技术创建的某个类的实例。同一个类的所有对象，都具有相似的数据和
      行为，但是每个对象都保存着自己独特的状态，对象状态会随着程序的运行而发生改变，需要注意
      状态的变化必须通过调用方法来改变，这就是封装的基本原则。

      封装思想：
              核心思想就是隐藏细节，数据安全，将对象不需要让外界访问的成员变量和方法私有化，
      值提供符合开发者医院的公有方法来访问这些数据和逻辑，保证了数据的安全和程序的稳定。

      Java中的访问权限：
          1）public 修饰符，具有最大的访问权限，可以访问任何一个在 CLASSPATH 下的类、接口、异常等。

　　      2）protected 修饰符，主要作用就是用来保护子类，子类可以访问这些成员变量和方法，其余类不可以。

　　      3）default 修饰符，主要是本包的类可以访问。

　　      5）private 修饰符，访问权限仅限于本类内部，在实际开发过程中，大多数的成员变量和方法都是使用 private 修饰的。
</pre>

<pre>
继承和类实例化过程
　　（1）在多个不同的类中抽取出共性的数据和逻辑，对这些共性的内容进行封装一个新的类即父类（也叫做超类或基类），让之前的类来继承这个类，那些共性的内容在子类中就不必重复定义，比如 BaseDAO、BaseAction 等。

　　* （2）Java 的继承机制是单继承，即一个类只能有一个直接父类。

　　* （3）如果子类和父类有同名成员变量和方法，子类可以使用 super 关键字调用父类的成员变量和方法，上述使用方式前提是成员在子类可见。

　　* （4）在调用子类构造方法时，会隐式的调用父类的构造方法 super()。如果父类没有无参构造方法，为了避免编译错误，需要在子类构造方法中显式的调用父类的含参构造方法。

　　（5）子类创建时调用父类构造方法：子类需要使用父类的成员变量和方法，所以就要调用父类构造方法来初始化，之后再进行子类成员变量和方法的初始化。因此，构造方法是无法覆盖的。

　　* （6）当子类需要扩展父类的某个方法时，可以覆盖父类方法，但是子类方法访问权限必须大于或等于父类权限。

　　（7）继承提高了程序的复用性、扩展性，也是 Java 语言多态特征的前提。

　　（8）在实际开发、程序设计过程中，并非先有的父类，而是先有了子类中通用的数据和逻辑，然后再抽取封装出来的父类。
</pre>

<pre>
类的实例化过程:

    （1）JVM 读取指定 classpath 路径下的 class 文件，加载到内存，如果有直接父类，也会加载父类；

　　（2）堆内存分配空间；

　　（3）执行父类、子类静态代码块；

　　（4）对象属性进行默认初始化；

　　（5）调用构造方法；

　　（6）在构造方法中，先调用父类构造方法初始化父类数据；

　　（7）初始化父类数据后，显示初始化，执行子类的构造代码块；

　　（8）再进行子类构造方法的特定初始化；

　　（9）初始化完毕后，将地址赋值给引用
</pre>

<pre>
多态、反射和组件解耦

      Java 的反射技术和多态特性是框架开发、组件解耦的核心，在这方面，Spring 的 IOC 和 DI 为
      我们提供了一个极好的学习范例，Spring 的 IOC 使用反射技术创建、管理对象，DI 使用多态技
      术为组件注入依赖对象。

      @Service

      public class Test{
			@Autowired
			@Qualifier("swan ")
			private Animal swan; //通过@Qualifier("swan")，先将Animal的实现类指向Peaclck，再注入
			
			@Autowired
			@Qualifier("peacock “)
			private Animal peacock; //通过@Qualifier("peacock")，先将Animal的实现类指向Peaclck，再注入

      说明：@Autowired 结合@Qualifier 可以实现按照名称来注入，如果不给每个实现类指定@Qualifier，
      在注入的过程会报以下异常:
			No qualifying bean of type Animal is defined: expected single matching bean but found 2
	  因为接口Animal有多个不同的实现类，spring容器不知道要给你注入哪个实现类，所以需要加上@Qualifier，加以区分
}
</pre>

![](https://i.imgur.com/X1Pkm8V.png)

<pre>
Spring IOC容器反射

      Spring反射: Class.forName().newInstance()

      Spring使用步骤：
          1.找到配置文件
          2.加载配置文件
          3.解析配置文件中的bean元素，并识别id和class
          5.通过反射（Class.forName().newInstance()）创建这个bean的实例
          6.将id作为key、实例作为value存放进Spring容器中
          7.getBean取出实例
</pre>